# 简单工厂的说明：

## 第一版：
### 面对业务，先做出一个小样例
> 第一版计算器程序，面向过程编程
> 
> 界面与业务耦合度较高 不易扩展，不易维护，不易复用
		
## 第二版：
 ### 针对增加的平台，我们做业务和界面的分离，封装算法，让方法可复用
> 封装算法业务逻辑 与界面分离
> 
> 其他比如 web、PDA、手机等系统都可以使用封装的方法(业务逻辑)
> 
> 但不能灵活地修改和扩展，每次修改算法，都会影响其他算法，还> 错的可能
> 
> 每次增加或减少一个算法 其他算法也要重新编译
	 
## 第三版：

### 面对变化的算法，我们需要分离算法，利用继承和多态，让算法不仅可复用，且更易维护，易扩展，更灵活，但我们需要一个简单工厂来对接前端需求，根据实际需要来实例化相应的子类

> 定义一个算法基类 这样每次增加或修改算法只用独立增加或修改就行了，
这就增加了灵活性，方便扩展，维护，复用
>
> 但前端界面并不知道要是用哪个算法，这就需要一个简单工厂来帮助前端自动创建需要的算法实例
> 
>如果需要增加算法，只管增加新类，继承自基类即可，实现自己的算法，在工厂类中增加相应的前端对接即可
>
>如果需要修改某一个算法，单独去修改就行了，增加或修改都不会影响其他算法

## 缺点

> 违背了开放封闭原则
> 
> 因为如果再增加一个算法，还要修改简单工厂中的case语句
> 
> 这个可以用工厂方法模式来化解，将不同的算法分离成不同的工厂
